<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Genesis System v5.0 // OMNI-REDUX</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">

<style>
    :root {
        --c-cyan: #00f3ff;
        --c-purple: #bc13fe;
        --c-gold: #ffd700;
        --c-dark: #010103;
        --scan-line: rgba(0, 243, 255, 0.03);
    }

    body {
        margin: 0;
        overflow: hidden;
        background: var(--c-dark);
        font-family: 'Share Tech Mono', monospace;
        color: var(--c-cyan);
    }

    /* --- EFECTOS DE PANTALLA --- */
    .screen-overlay {
        position: absolute;
        width: 100vw;
        height: 100vh;
        background: repeating-linear-gradient(
            0deg,
            var(--scan-line) 0px,
            var(--scan-line) 1px,
            transparent 2px,
            transparent 4px
        );
        pointer-events: none;
        z-index: 90;
    }
    
    .vignette {
        position: absolute;
        width: 100%;
        height: 100%;
        box-shadow: inset 0 0 150px rgba(0,0,0,0.9);
        pointer-events: none;
        z-index: 80;
    }

    /* --- UI LAYOUT --- */
    .hud-container {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        z-index: 100;
        padding: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }

    /* HEADER */
    .top-bar {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        border-top: 2px solid var(--c-purple);
        padding-top: 10px;
    }

    .system-status {
        font-family: 'Rajdhani', sans-serif;
        font-weight: 700;
        font-size: 24px;
        letter-spacing: 2px;
        text-shadow: 0 0 10px var(--c-purple);
    }
    
    .sub-status {
        font-size: 12px;
        color: rgba(255,255,255,0.7);
        margin-top: 5px;
    }

    .coordinate-box {
        text-align: right;
        font-size: 11px;
        line-height: 1.4;
    }

    /* CENTER RETICLE */
    .center-focus {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        width: 600px;
        height: 600px;
        border: 1px dashed rgba(188, 19, 254, 0.2); /* Purple tint */
        border-radius: 50%;
        animation: rotateReticle 120s linear infinite;
    }
    .center-focus::before, .center-focus::after {
        content: ''; position: absolute;
        top: 50%; left: 50%; transform: translate(-50%, -50%);
        border: 1px solid rgba(0, 243, 255, 0.1);
        border-radius: 50%;
    }
    .center-focus::before { width: 80%; height: 80%; }
    .center-focus::after { width: 120%; height: 120%; border-color: rgba(255, 215, 0, 0.05); }

    @keyframes rotateReticle { to { transform: translate(-50%, -50%) rotate(360deg); } }

    /* SIDE DATA STREAMS */
    .side-panel {
        position: absolute;
        top: 50%; 
        transform: translateY(-50%);
        width: 200px;
        font-size: 10px;
        opacity: 0.8;
    }
    .left-panel { left: 30px; border-left: 1px solid var(--c-cyan); padding-left: 10px; }
    .right-panel { right: 30px; text-align: right; border-right: 1px solid var(--c-purple); padding-right: 10px; color: var(--c-purple); }

    .data-row { margin-bottom: 8px; }
    .label { color: white; opacity: 0.5; }
    .value { font-weight: bold; }

    /* FOOTER */
    .bottom-bar {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        border-bottom: 2px solid var(--c-cyan);
        padding-bottom: 10px;
    }
    
    .loading-bar-container {
        width: 300px;
        height: 4px;
        background: rgba(255,255,255,0.1);
        position: relative;
    }
    .loading-bar {
        position: absolute;
        top: 0; left: 0; height: 100%; width: 50%;
        background: var(--c-cyan);
        box-shadow: 0 0 10px var(--c-cyan);
        animation: scanLoad 3s ease-in-out infinite alternate;
    }
    @keyframes scanLoad { 0% { width: 10%; left: 0; } 100% { width: 30%; left: 70%; } }

</style>
</head>
<body>

<div class="vignette"></div>
<div class="screen-overlay"></div>

<div class="hud-container">
    <div class="top-bar">
        <div>
            <div class="system-status">OMNI // REDUX</div>
            <div class="sub-status">CONNECTED TO DEEP SPACE NETWORK</div>
        </div>
        <div class="coordinate-box">
            SECTOR: 7G-ALPHA<br>
            PARALLAX: 4.22 LY<br>
            SPECTRAL: O-TYPE
        </div>
    </div>

    <div class="center-focus"></div>

    <div class="side-panel left-panel">
        <div class="data-row"><span class="label">CORE_TEMP:</span> <span class="value" id="temp">4500 K</span></div>
        <div class="data-row"><span class="label">MAG_FIELD:</span> <span class="value" id="mag">12.4 T</span></div>
        <div class="data-row"><span class="label">SPIN_RATE:</span> <span class="value" id="spin">1,400 m/s</span></div>
        <div class="data-row"><span class="label">ENTROPY:</span> <span class="value">STABLE</span></div>
        <br>
        <div style="color:var(--c-gold)">> ANALYZING GEOMETRY...</div>
        <div style="color:var(--c-gold)">> PLEXUS SYNC: 100%</div>
    </div>

    <div class="side-panel right-panel">
        <div class="data-row"><span class="value">ASTROMETRY_MODULE</span></div>
        <div class="data-row">X: <span id="valX">0.00</span></div>
        <div class="data-row">Y: <span id="valY">0.00</span></div>
        <div class="data-row">Z: <span id="valZ">0.00</span></div>
        <br>
        <div class="data-row" style="color: white;">/// ENCRYPTION: NONE</div>
    </div>

    <div class="bottom-bar">
        <div class="loading-bar-container">
            <div class="loading-bar"></div>
        </div>
        <div style="font-size: 10px; opacity: 0.6;">
            RENDER_ENGINE: WEBGL2.0<br>
            VERSION: 5.0.21
        </div>
    </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

// --- CONFIGURACIÓN DE ESCENA ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x010103);
scene.fog = new THREE.FogExp2(0x010103, 0.015);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 8);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

// --- 1. EL NÚCLEO (ASTEROIDE DE ALTA COMPLEJIDAD) ---
const geometry = new THREE.IcosahedronGeometry(2, 80); // Mayor resolución
const pos = geometry.attributes.position;
const colors = [];
const v = new THREE.Vector3();
const colorDark = new THREE.Color("#050014"); // Base oscura (casi negra)
const colorHigh = new THREE.Color("#00f3ff"); // Picos Cyan
const colorMid = new THREE.Color("#6200ea");  // Púrpura medio

for (let i = 0; i < pos.count; i++) {
    v.fromBufferAttribute(pos, i);
    
    // Algoritmo de ruido pseudo-aleatorio para terreno complejo
    const n1 = Math.sin(v.x * 3.5) * Math.cos(v.y * 3.5) * Math.sin(v.z * 3.5);
    const n2 = Math.sin(v.x * 10 + 2) * Math.cos(v.y * 8) * 0.1;
    
    const noise = (n1 * 0.3) + (n2 * 0.1);
    const displacement = 1 + noise;
    
    v.multiplyScalar(displacement);
    pos.setXYZ(i, v.x, v.y, v.z);

    // Sistema de coloración basado en altura (altimetría)
    let c = colorDark.clone();
    if (noise > 0.15) {
        c.lerp(colorHigh, (noise - 0.15) * 4); // Picos muy brillantes
    } else if (noise > 0) {
        c.lerp(colorMid, noise * 3); // Zonas medias púrpuras
    }
    colors.push(c.r, c.g, c.b);
}
geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
geometry.computeVertexNormals();

const material = new THREE.MeshStandardMaterial({
    vertexColors: true,
    roughness: 0.5,
    metalness: 0.8,
    emissive: 0x000000,
});

const planet = new THREE.Mesh(geometry, material);
scene.add(planet);

// --- 2. ATMÓSFERA VOLUMÉTRICA (SHADER FRESNEL) ---
const atmosGeo = new THREE.IcosahedronGeometry(2.4, 40);
const atmosMat = new THREE.ShaderMaterial({
    uniforms: {
        cVector: { type: "v3", value: new THREE.Vector3(0, 0, 1) },
        pColor: { type: "c", value: new THREE.Color(0x00f3ff) },
        sColor: { type: "c", value: new THREE.Color(0xbc13fe) }
    },
    vertexShader: `
        varying vec3 vNormal;
        void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
    `,
    fragmentShader: `
        uniform vec3 cVector;
        uniform vec3 pColor;
        uniform vec3 sColor;
        varying vec3 vNormal;
        void main() {
            float intensity = pow(0.5 - dot(vNormal, cVector), 3.5);
            // Mezcla de Cyan y Púrpura en la atmósfera
            vec3 glow = mix(pColor, sColor, intensity * 2.0);
            gl_FragColor = vec4(glow, 1.0) * intensity;
        }
    `,
    blending: THREE.AdditiveBlending,
    side: THREE.BackSide,
    transparent: true
});
const atmosphere = new THREE.Mesh(atmosGeo, atmosMat);
scene.add(atmosphere);

// --- 3. FONDO PLEXUS (INSPIRADO EN IMAGEN 1) ---
// Líneas que conectan estrellas cercanas
const plexusGroup = new THREE.Group();
const pCount = 350;
const pGeom = new THREE.BufferGeometry();
const pPositions = [];
const pVelocities = [];

for(let i=0; i<pCount; i++) {
    const r = 6 + Math.random() * 10;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos((Math.random() * 2) - 1);
    
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.sin(phi) * Math.sin(theta);
    const z = r * Math.cos(phi);
    
    pPositions.push(x, y, z);
    pVelocities.push({
        x: (Math.random() - 0.5) * 0.01,
        y: (Math.random() - 0.5) * 0.01,
        z: (Math.random() - 0.5) * 0.01
    });
}
// Renderizamos solo los puntos, las líneas se harán dinámicamente si es necesario, 
// pero para optimizar usaremos una "Wireframe Sphere" gigante de fondo.
const plexusDots = new THREE.Points(
    new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(pPositions, 3)),
    new THREE.PointsMaterial({ color: 0xbc13fe, size: 0.05, transparent: true, opacity: 0.6 })
);
plexusGroup.add(plexusDots);

// Añadir una estructura de red geométrica grande rotando (Estilo Constelación)
const wireGeo = new THREE.IcosahedronGeometry(12, 2);
const wireMat = new THREE.MeshBasicMaterial({ 
    color: 0x3d0075, 
    wireframe: true, 
    transparent: true, 
    opacity: 0.15 
});
const net = new THREE.Mesh(wireGeo, wireMat);
scene.add(net);
scene.add(plexusGroup);

// --- 4. HAZ DE LUZ VERTICAL (INSPIRADO EN IMAGEN 2) ---
const beamGeo = new THREE.CylinderGeometry(0.1, 0.1, 40, 32);
const beamMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.15,
    blending: THREE.AdditiveBlending
});
const beam = new THREE.Mesh(beamGeo, beamMat);
beam.rotation.x = 0; // Vertical
scene.add(beam);

// Añadir un anillo orbital plano
const ringGeo = new THREE.RingGeometry(3.5, 3.6, 64);
const ringMat = new THREE.MeshBasicMaterial({ 
    color: 0xffd700, 
    side: THREE.DoubleSide, 
    transparent: true, 
    opacity: 0.3,
    blending: THREE.AdditiveBlending
});
const ring = new THREE.Mesh(ringGeo, ringMat);
ring.rotation.x = Math.PI / 2;
scene.add(ring);


// --- ILUMINACIÓN DRAMÁTICA ---
const ambientLight = new THREE.AmbientLight(0x000000); 
scene.add(ambientLight);

// Luz Azul (Lado A)
const l1 = new THREE.PointLight(0x00f3ff, 150, 50);
l1.position.set(5, 2, 5);
scene.add(l1);

// Luz Púrpura (Lado B - Contraste)
const l2 = new THREE.PointLight(0xbc13fe, 100, 50);
l2.position.set(-5, -3, -5);
scene.add(l2);

// Luz Dorada (Centro/Vertical - Imagen 2)
const l3 = new THREE.PointLight(0xffaa00, 20, 20);
l3.position.set(0, 5, 0);
scene.add(l3);


// --- POST-PROCESADO (BLOOM) ---
const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    1.6,  // Intensidad
    0.5,  // Radio
    0.1   // Umbral
);
composer.addPass(bloomPass);

// --- ANIMACIÓN ---
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.8;
controls.minDistance = 4;
controls.maxDistance = 15;

const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    // Rotación del planeta
    planet.rotation.y += 0.003;
    planet.rotation.z = Math.sin(t * 0.2) * 0.15;

    // Animación de la atmósfera (respiración)
    const pulse = 1 + Math.sin(t * 1.5) * 0.02;
    atmosphere.scale.setScalar(pulse);

    // Rotación de la red de fondo (Constelaciones)
    net.rotation.y -= 0.001;
    net.rotation.x += 0.0005;

    // Animación del anillo
    ring.rotation.z = t * 0.1;
    ring.rotation.x = (Math.PI / 2) + Math.sin(t * 0.5) * 0.1;

    // Actualizar luces dinámicas
    l1.intensity = 150 + Math.sin(t * 3) * 20;

    // Actualizar HUD data
    document.getElementById('valX').innerText = (Math.sin(t)*10).toFixed(4);
    document.getElementById('valY').innerText = (Math.cos(t)*10).toFixed(4);
    document.getElementById('valZ').innerText = (Math.tan(t*0.1)).toFixed(4);
    document.getElementById('temp').innerText = (4500 + Math.random()*50).toFixed(0) + " K";

    controls.update();
    composer.render();
}

animate();

window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
